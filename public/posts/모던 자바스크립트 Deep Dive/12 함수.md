# 12 함수

## 12.1 함수란?

- 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 함수 정의(definition): 함수 이름 / 매개 변수(parameter; 함수 내부로 입력을 전달받는 변수) / 함수 몸통 / 반환 값(return value)
- 함수 호출(function call/invoke): 인수(argument; 입력)
- 함수를 호출하면 코드 블록에 담긴 문들이 일관적으로 실행되고, 실행결과를 반환한다.

## 12.2 함수를 사용하는 이유

1. 코드의 재사용성
2. 유지보스의 편리서
3. 코드의 신뢰성
4. 코드의 가독성

## 12.3 함수 리터럴

함수는 객체 타입의 값이다. 다른 객체 타입 처럼 함수도 함수 리터럴로 생성 할 수 있다.

```js
var f = function add(x, y) {
  return x + y;
};
```

함수 이름(add)는 함수 몸통 내부에서만 참조할 수 있는 식별자다.

매개변수(x, y)는 함수 몸통 내부에서 변수로 동일하게 취급된다.

함수는 일반 객체와 달리 호출할 수 있고, 함수 객체 고유한 프로퍼티를 갖는다.

## 12.4 함수 정의

함수 선언문

```js
function add(x, y) {
  return x + y;
}

console.dir(add);
// console.dir은 함수 객체의 프로퍼티까지 출력한다.
// add(x, y)
console.log(add(2, 5)); // 7
```

함수 표현식

```js
var add = function (x, y) {
  return x + y;
};
```

Function 생성자 함수

```js
var add = new Function("x", "y", "return x + y");
```

화살표 함수(ES6)

```js
var add = (x, y) => x + y;
```

변수 선언(declaration), 함수 정의(definition): 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.

### 함수 선언문

- 함수 이름을 생략 할 수 없다
- 함수 선언문은 표현식이 아니라 문이다. 값으로 평가 될 수 없다. 선언문을 실행하면 완료 값 undefined가 출력된다.
- 값으로 평가 될 수 없는 문은 변수에 할당할 수 없다.
- 자바스크립트 엔진에 의해 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다.
- {}: 값으로 평가 되어야 할 때는 객체 리터럴로, 그렇지 않을 경우에는 코드 블록으로 해석된다.

```js
// 기명 함수 리터럴
// 함수 선언문 해석
// 함수 이름 필수

function foo() {
  console.log("foo");
}
foo(); // foo

// 기명 함수 리터럴
// 함수 리터럴 표현식으로 해석
// 함수 이름 생략 가능

// 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식이여야 한다.
(function bar() {
  console.log("bar");
});
bar(); // ReferenceError
```

- 자바스크립트는 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당 한다.
- 함수를 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
- 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다.

```js
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var add = function add(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

### 함수 표현식

자바스크립트의 함수는 일급 객체다. (함수를 값처럼 자유롭게 사용할 수 있다.)

함수 표현식은 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 방식이다.

함수 선언문은 "표현식이 아닌 문"이고 함수 표현식은 "표현식인 문"이다.

```js
var add = function (x, y) {
  return x + y;
};
console.log(add(2, 5)); // 7
```

### 함수 생성 시점과 함수 호이스팅

```js
// 함수 참조
console.dir(add); // add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.
- 함수 선언문(함수 호이스팅)
  - 런타임 이전에 실행되어 함수 객체로 초기화 하고 함수 이름과 동일한 식별자를 암묵적으로 생성하고 생성된 개체를 할당한다.
  - 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징
- 함수 표현식(변수 호이스팅)
  - 런타임 이전에 실행되어 undefined로 초기화 한다.
  - 함수 리터럴문은 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
- 함수 선언문은 런타임 이전에 함수 객체를 생성하고, 함수 표현식은 런타임에 함수 객체를 생성한다.
- 함수 호이스팅은 함수를 사용하기 전에 선언해야한다는 당연한 규칙을 무기하기 때문에 함수 표현식을 사용하길 권고 한다. (더글라스 크락포트)

### Function 생성자 함수

```js
var add = new Function("x", "y", "return x + y");

console.log(add(2, 5)); // 7
```

Function 생성자 함수로 생성한 함수는 클로저(Closure)를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.

### 화살표 함수

기존의 함수보다 간략하게 동작한다.

1. 생성자 함수로 사용할 수 없다.
2. this 바인딩
3. prototype 프로퍼티 X
4. arguments 객체 X

## 12.5 함수 호출

### 매개변수와 인수

함수 실행에 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는 경우, 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다.

함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다.

- 매개변수 > 인수: 부족한 매개변수는 초기값(undefined)으로 함수가 실행된다.
- 매개변수 < 인수: 초과된 인수는 무시된다.
- 모든 인수는 arguments 객체의 프로퍼티로 보관된다.

### 인수 확인

자바스크립트의 경우 함수를 정의할 때 적정한 인수가 전달되었는지 확인할 필요가 있다.

- 인수의 갯수: 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
- 인수의 타입: 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.

```js
function add(x, y) {
  // 전달된 인수의 타입이 부적절한 경우 에러를 발생시킨다.
  if (typeof x !== "number" || typeof y !== "number") {
    throw new TypeError("인수는 모두 숫자 값이여야 합니다.");
  }
  return x + y;
}
```

```js
function add(a, b, c) {
  // 인수가 전달되지 않았을 때 단축 평가를 사용해 기본값을 할당 할 수 있다.
  a = a || 0;
  b = b || 0;
  c = c || 0;
  return a + b + c;
}
```

```js
function add(a = 0, b = 0, c = 0) {
  // ES6 매개변수 기본값을 사용하면 인수 체크 및 초기화를 간소화 시킬 수 있다.
  return a + b + c;
}
```

### 매개변수와 최대 개수

이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.

매개변수가 3개 이상일 때는 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.

함수 내부로 전달된 객체가 내부에서 변경 될 경우 함수 외부의 객체가 변경 되는 부수 효과(side effect)가 발생한다.

### 반환문

반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있다.

반환문은 함수의 실행을 중단하고 함수 몸통을 빠져나가기 때문에 반환문 이후의 문은 실행되지 않는다.

반환문 뒤의 표현식을 평가하여 값을 반환하고, 값이 없다면 undefined를 반환한다.

반환문이 없으면 함수는 함수 몸통 마지막 문까지 실행 후 undefined를 반환한다.

반환문은 함수 몸통 안에서만 사용 할 수 있다. (Node.js는 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 갑는다.)

## 12.6 참조에 의한 전달과 외부 상태의 변경

매개변수도 함수 내부에서 변수와 동일하게 취급된다.

원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달된다.

원시 값은 원본이 훼손되지 않지만, 객체는 원본이 훼손된다.

대안

- 옵저버 패턴(Observer): 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처한다.
- 불변 객체(immutable object): 객체를 원시 값처럼 변경 불가능한 값으로 동작하게 한다.
- 방어적 복사(defensive copy): 원본 객체를 깊은 복사하여 새로운 객체를 생성하고 재할당을 통해 교체한다.

순수 함수

- 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는다.

함수형 프로그래밍

- 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이는 프로그램 패러다임

## 12.7 다양한 함수의 형태

### 즉시 실행 함수(IFE, Immediately Invoked Function Expression)

함수 정의와 동시에 즉시 호출되는 함수

익명 함수(함수 표현식)를 그룹 연산자로 감싸고 바로 호출한다. 그룹 연산자는 피연산자인 함수 표현식을 함수 리터럴로 평가하여 함수 객체를 생성한다.

```js
// 반환값
var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
})();

console.log(res); // 15

// 인수 전달
res = (function (a, b) {
  return a * b;
})(3, 5);

console.log(res); // 15
```

즉시 실행 함수를 통해 변수나 함수 이름의 충돌을 방지할 수 있다.

### 재귀함수(recursive function)

함수 내부에서 자기 자신을 호출하는 함수

반복되는 처리를 위해 사용한다

함수 몸통안에 탈출 조건을 반드시 만들어 무한 재귀 호출을 방지한다. (stack oveflow)

재귀 함수는 반복문으로 사용하는 것보다 직관적으로 이해하기 쉬울 때만 사용한다

```js
// 함수 선언문
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 120

// 함수 표현식
var factorial = function foo(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // 식별자로 호출
  // return n * foo(n - 1); // 함수 이름으로 호출
};

console.log(factorial(5)); // 120
```

### 중첩함수

함수 내부에 정의된 함수

- 중첩함수(nested function), 내부 함수(inner function)
- 외부함수를 돕는 핼퍼 함수(helper function) 역할을 한다.
- 호이스팅으로 인한 혼란이 발생할 수 있으므로 if 문이나 for문 등의 코드 블록에서 함수 선언문을 통해 함수를 정의하는 것은 바람직하지 않다.

```js
function outer() {
  var x = 1;
  function inner() {
    var y = 2;
    console.log(x + y); // 3
  }
  inner();
}

outer();
```

### 콜백함수

함수의 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화해서 외부에서 함수 내부로 전달할 수 있다.

콜백함수(callback function): 함수의 매개변수를 통해 다름 함수의 내부로 전달되는 함수

고차 함수(Higher Order Function, HOI)

- 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
- 매개변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수
- 콜백 함수를 자신의 일부분으로 합성한다.
- 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인자를 전달 할 수 있다.

```js
// 익명 함수 리터럴을 콜백 함수로 고차 함수에 전달
// 익명 함수 리터럴은 고차 함수(repeat)를 호출할 때마다 평가되어 함수 객체를 생성
repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 1 3
```

```js
// logOdds 함수는 단 한 번만 생성
// 고차 함수에 함수 참조를 전달
const logOdds = function () {
  if (i % 2) console.log(i);
};
repeat(5, logOdds); // 1 3
```

콜백 함수

- 함수형 프로그래밍 패러다임
- 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수)
- 배열 고차 함수(map, filter, reduce)

### 순수 함수와 비순수 함수

순수 함수(fure function)

- 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 부수 효과가 없는 함수
- 동일한 인수가 전달되면 언제나 동일한 값을 반환

```js
var count = 0;
function increase(n) {
  return ++n; // 동일한 인수가 전될되면 동일한 값을 반환한다.
}
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```

비순수 함수(imfure function)

- 외부의 상태에 의존하거나 외부 상태를 변경하는 함수

```js
var count = 0;
function increase() {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```
